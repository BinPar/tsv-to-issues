'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

let createAllLabelsNeeded = (() => {
  var _ref = _asyncToGenerator(function* (gh, labels) {
    if (labels && labels.length > 0) {
      const { data } = yield gh.listLabels();
      yield Promise.all(labels.filter(function (label) {
        return !data.some(function (githubLabel) {
          return githubLabel.name.toLowerCase() === label.toLowerCase();
        });
      }).map(function (labelName) {
        return gh.createLabel({
          name: labelName,
          color: (0, _randomcolor2.default)().replace('#', '')
        });
      }));
    }
  });

  return function createAllLabelsNeeded(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let createDefaultColumnsForNewProjects = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    const projects = PROJECTS.filter(function (p) {
      return p.isNew;
    });
    for (let i = 0, l = projects.length; i < l; i += 1) {
      const { ghWrapper } = projects[i];
      const { data: toDo } = yield ghWrapper.createProjectColumn({
        name: 'ToDo'
      });
      yield ghWrapper.createProjectColumn({
        name: 'In Progress'
      });
      yield ghWrapper.createProjectColumn({
        name: 'Done'
      });
      projects[i].idToDoCol = toDo.id;
    }
  });

  return function createDefaultColumnsForNewProjects() {
    return _ref2.apply(this, arguments);
  };
})();

let createAllProjectsNeeded = (() => {
  var _ref3 = _asyncToGenerator(function* (gh, ghRepository, projects) {
    if (projects && projects.length > 0) {
      try {
        const { data } = yield ghRepository.listProjects();
        const projectsDataArray = yield Promise.all(projects.filter(function (project) {
          return !data.some(function (githubProject) {
            return githubProject.name === project;
          });
        }).map(function (projectName) {
          return ghRepository.createProject({
            name: projectName
          });
        }));
        for (let i = 0, l = data.length; i < l; i += 1) {
          const { id, name } = data[i];
          if (id) {
            const project = {
              id,
              name,
              ghWrapper: gh.getProject(id)
            };
            const { data: cols } = yield project.ghWrapper.listProjectColumns();
            const toDoCol = cols.find(function (c) {
              return c.name === 'ToDo';
            });
            if (toDoCol) {
              project.idToDoCol = toDoCol.id;
            }
            PROJECTS.push(project);
          }
        }
        projectsDataArray.forEach(function ({ data: projectData }) {
          if (projectData.id) {
            PROJECTS.push({
              id: projectData.id,
              name: projectData.name,
              isNew: true,
              ghWrapper: gh.getProject(projectData.id)
            });
          }
        });
        yield createDefaultColumnsForNewProjects();
      } catch (err) {
        console.log(_chalk2.default.red(err.response.data));
      }
    }
  });

  return function createAllProjectsNeeded(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
})();

let ensureAssigneesCanBeAssigned = (() => {
  var _ref4 = _asyncToGenerator(function* (gh, ghOrganization, names, repositoryName, repositoryOwner, assignees) {
    if (assignees && assignees.length > 0) {
      const { data } = yield ghOrganization.getTeams();
      const teams = data.filter(function ({ name }) {
        return names.indexOf(name) !== -1;
      });
      const assigneesNotFound = assignees.map(function (a) {
        return a.toLowerCase();
      });
      if (teams && teams.length > 0) {
        teams.forEach(function ({ id, name }) {
          if (id) {
            TEAMS.push({
              id,
              name,
              ghWrapper: gh.getTeam(id)
            });
          }
        });
        const result = yield Promise.all(TEAMS.map(function (team) {
          return team.ghWrapper.listMembers();
        }));
        for (let i = 0, l = result.length; i < l; i += 1) {
          const { data: members } = result[i];
          for (let j = 0, l2 = members.length; j < l2; j += 1) {
            const { login } = members[j];
            const index = assigneesNotFound.indexOf(login.toLowerCase());
            if (index >= 0) {
              assigneesNotFound.splice(index, 1);
            }
          }
        }
      }
      if (!teams || teams.length === 0 || assigneesNotFound.length > 0) {
        try {
          const { data: resData } = yield ghOrganization.createTeam({
            name: `${hyphenToCamelCase(repositoryName)}Dev`,
            description: 'Automatically generated by TSVToIssues to ensure the issues assignment',
            repo_names: [repositoryName],
            privacy: 'closed'
          });
          const ghWrapper = gh.getTeam(resData.id);
          TEAMS.push({
            id: resData.id,
            name: resData.name,
            ghWrapper
          });
          for (let i = 0, l = assignees.length; i < l; i += 1) {
            const assignee = assignees[i];
            yield ghWrapper.addMembership(assignee);
          }
          yield ghWrapper.manageRepo(repositoryOwner, repositoryName, { permission: 'admin' });
          console.log(_chalk2.default.green(`=> Default repository team created (${hyphenToCamelCase(repositoryName)}Dev)`));
        } catch (err) {
          const repoTeam = TEAMS.find(function (t) {
            return t.name === `${hyphenToCamelCase(repositoryName)}Dev`;
          });
          if (repoTeam) {
            for (let i = 0, l = assigneesNotFound.length; i < l; i += 1) {
              const assignee = assigneesNotFound[i];
              yield repoTeam.ghWrapper.addMembership(assignee);
            }
            yield repoTeam.ghWrapper.manageRepo(repositoryOwner, repositoryName, {
              permission: 'admin'
            });
            console.log(_chalk2.default.green('=> Added assignees to default repository team'));
          }
        }
      }
    }
  });

  return function ensureAssigneesCanBeAssigned(_x6, _x7, _x8, _x9, _x10, _x11) {
    return _ref4.apply(this, arguments);
  };
})();

let createIssue = (() => {
  var _ref5 = _asyncToGenerator(function* (ghIssue, issue) {
    return ghIssue.createIssue({
      title: issue.title,
      body: issue.description,
      assignees: issue.assignees instanceof Array ? issue.assignees : [issue.assignees],
      labels: issue.labels instanceof Array ? issue.labels : [issue.labels]
    });
  });

  return function createIssue(_x12, _x13) {
    return _ref5.apply(this, arguments);
  };
})();

let createProjectCard = (() => {
  var _ref6 = _asyncToGenerator(function* ({ project: projectName }, id, number) {
    if (projectName) {
      const { ghWrapper, idToDoCol } = PROJECTS.find(function (p) {
        return p.name === projectName;
      });
      yield ghWrapper.createProjectCard(idToDoCol, {
        content_id: id,
        content_type: 'Issue'
      });
      console.log(_chalk2.default.green(`=> Issue #${number} added to project ${projectName}`));
    }
  });

  return function createProjectCard(_x14, _x15, _x16) {
    return _ref6.apply(this, arguments);
  };
})();

var _githubApi = require('github-api');

var _githubApi2 = _interopRequireDefault(_githubApi);

var _randomcolor = require('randomcolor');

var _randomcolor2 = _interopRequireDefault(_randomcolor);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint no-await-in-loop: "off" */


const PROJECTS = [];
const TEAMS = [];

function hyphenToCamelCase(str) {
  return str.split('').reduce((v, a) => {
    if (v[v.length - 1] === '-') {
      return `${v.slice(0, -1)}${a.toUpperCase()}`;
    }
    return v + a;
  }, '');
}

function getIssuesFromTSV(tsvPath) {
  try {
    const tsvStr = _fs2.default.readFileSync(tsvPath, 'utf8');
    return tsvStr.split('\n').map(issueStr => issueStr.split('\t').map(s => s.trim().split(' ').filter(st => st).join(' '))).map(issuePropsArray => ({
      title: issuePropsArray[0],
      description: issuePropsArray[1],
      assignees: issuePropsArray[2] ? issuePropsArray[2].split(',').map(s => s.trim()) : issuePropsArray[2],
      labels: issuePropsArray[3] ? issuePropsArray[3].split(',').map(s => s.trim()) : issuePropsArray[3],
      project: issuePropsArray[4]
    }));
  } catch (err) {
    console.log(err);
    return null;
  }
}

function getGitHubClient(authOptions) {
  return new _githubApi2.default(authOptions);
}

function getAllLabelsFromIssues(issues) {
  const dedupLabelsObj = {};
  issues.forEach(issue => {
    if (issue.labels && issue.labels.length > 0) {
      issue.labels.forEach(label => {
        dedupLabelsObj[label] = true;
      });
    }
  });
  return Object.keys(dedupLabelsObj);
}

function getAllProjectsFromIssues(issues) {
  const dedupProjectsObj = {};
  issues.forEach(issue => {
    if (issue.project) {
      dedupProjectsObj[issue.project] = true;
    }
  });
  return Object.keys(dedupProjectsObj);
}

function getAllAssigneesFromIssues(issues) {
  const dedupAssigneesObj = {};
  issues.forEach(issue => {
    if (issue.assignees && issue.assignees.length > 0) {
      issue.assignees.forEach(assignee => {
        dedupAssigneesObj[assignee] = true;
      });
    }
  });
  return Object.keys(dedupAssigneesObj);
}

exports.default = (() => {
  var _ref7 = _asyncToGenerator(function* ({
    username,
    password,
    token,
    tsvPath,
    repository,
    teams
  }) {
    const [repositoryName, repositoryOwner] = repository.split('/').reverse();

    let gh;
    if (token) {
      gh = getGitHubClient({ token });
    } else {
      gh = getGitHubClient({ username, password });
    }
    const ghIssue = gh.getIssues(repositoryOwner, repositoryName);
    const ghOrganization = gh.getOrganization(repositoryOwner);
    const ghRepository = gh.getRepo(repositoryOwner, repositoryName);
    const issues = getIssuesFromTSV(tsvPath);
    if (!issues) {
      return { ok: false, error: 'Error reading tsv file' };
    }
    if (issues.length === 0) {
      return { ok: false, error: 'There are no issues in this tsv file' };
    }
    console.log(_chalk2.default.green('Creating labels...'));
    yield createAllLabelsNeeded(ghIssue, getAllLabelsFromIssues(issues));
    console.log(_chalk2.default.green('=> OK'));
    console.log(_chalk2.default.green('Creating projects...'));
    yield createAllProjectsNeeded(gh, ghRepository, getAllProjectsFromIssues(issues));
    console.log(_chalk2.default.green('=> OK'));
    let teamNames = [];
    if (teams && teams.length > 0) {
      teamNames = [...teams];
    }
    teamNames.push(`${hyphenToCamelCase(repositoryName)}Dev`);
    console.log(_chalk2.default.green('Checking repository teams & members...'));
    yield ensureAssigneesCanBeAssigned(gh, ghOrganization, teamNames, repositoryName, repositoryOwner, getAllAssigneesFromIssues(issues));
    console.log(_chalk2.default.green('Starting issue creation...'));
    for (let i = 0, l = issues.length; i < l; i += 1) {
      const issue = issues[i];
      try {
        const { data: issueRes } = yield createIssue(ghIssue, issue);
        console.log(_chalk2.default.green(`=> Issue #${issueRes.number} created`));
        try {
          yield createProjectCard(issue, issueRes.id, issueRes.number);
        } catch (err) {
          console.log(_chalk2.default.red(`The issue #${issueRes.number} could not be assigned to project ${issue.project}`));
        }
      } catch (err) {
        console.log(_chalk2.default.red(`The issue of line number ${i + 1} could not be created`));
      }
    }

    return { ok: true };
  });

  function processTSVAndCreateIssues(_x17) {
    return _ref7.apply(this, arguments);
  }

  return processTSVAndCreateIssues;
})();